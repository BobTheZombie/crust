use crate::backend::{Backend, BackendEmitResult};
use crate::graph::{DependencyGraph, TargetKind};
use anyhow::Result;
use std::fs;
use std::path::Path;

pub struct NinjaBackend;

impl Backend for NinjaBackend {
    fn name(&self) -> &str {
        "ninja"
    }

    fn emit(&self, graph: &DependencyGraph, out_dir: &Path) -> Result<BackendEmitResult> {
        fs::create_dir_all(out_dir)?;
        let mut lines = Vec::new();
        lines.push("rule stamp".to_string());
        lines.push("  command = touch $out".to_string());
        lines.push("".to_string());

        for node in graph.topo_order()? {
            let deps: Vec<String> = node
                .dependencies
                .iter()
                .map(|dep| format!("${{builddir}}/{dep}"))
                .collect();
            let inputs = if node.sources.is_empty() {
                deps.clone()
            } else {
                node.sources
                    .iter()
                    .map(|s| format!("${{srcdir}}/{s}"))
                    .chain(deps.into_iter())
                    .collect()
            };

            let outputs: Vec<String> = node
                .outputs
                .iter()
                .map(|o| format!("${{builddir}}/{o}"))
                .collect();

            let description = match node.kind {
                TargetKind::Executable => format!("link {name}", name = node.name),
                TargetKind::StaticLibrary => format!("archive {name}", name = node.name),
                TargetKind::SharedLibrary => format!("shared {name}", name = node.name),
                TargetKind::CustomCommand => format!("custom {name}", name = node.name),
            };

            for output in &outputs {
                lines.push(format!("build {output}: stamp {}", inputs.join(" ")));
                lines.push(format!("  description = {description}"));
                if let Some(cmd) = &node.command {
                    lines.push(format!("  command = {}", cmd));
                }
                lines.push(String::new());
            }
        }

        lines.push("default ${builddir}".to_string());

        let path = out_dir.join("build.ninja");
        let mut content = String::new();
        content.push_str("# Auto-generated by crust\n");
        content.push_str("builddir = ");
        content.push_str(out_dir.to_string_lossy().as_ref());
        content.push_str("\n");
        content.push_str("srcdir = .\n\n");
        content.push_str(&lines.join("\n"));
        content.push('\n');
        fs::write(&path, content)?;
        Ok(BackendEmitResult::single(path))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::{ProjectInfo, ProjectManifest, Target};
    use tempfile::tempdir;

    #[test]
    fn writes_build_ninja() {
        let manifest = ProjectManifest {
            project: ProjectInfo {
                name: "demo".into(),
                version: None,
            },
            targets: vec![Target::Executable {
                name: "app".into(),
                sources: vec!["src/main.c".into()],
                deps: vec![],
            }],
        };
        let graph = DependencyGraph::from_manifest(&manifest).unwrap();
        let dir = tempdir().unwrap();
        let backend = NinjaBackend;
        let result = backend.emit(&graph, dir.path()).unwrap();
        let content = std::fs::read_to_string(&result.files[0]).unwrap();
        assert!(content.contains("builddir ="));
        assert!(content.contains("build ${builddir}/app"));
    }
}
