use crate::backend::{Backend, BackendEmitResult};
use crate::graph::{DependencyGraph, TargetKind};
use anyhow::Result;
use std::fs;
use std::path::Path;

pub struct MakeBackend;

impl Backend for MakeBackend {
    fn name(&self) -> &str {
        "make"
    }

    fn emit(&self, graph: &DependencyGraph, out_dir: &Path) -> Result<BackendEmitResult> {
        fs::create_dir_all(out_dir)?;
        let mut content = String::new();
        content.push_str("# Auto-generated by crust\n\n");
        content.push_str("SRCROOT := ..\n");
        content.push_str("BUILDDIR := .\n\n");

        for node in graph.topo_order()? {
            let outputs: Vec<String> = node
                .outputs
                .iter()
                .map(|o| format!("$(BUILDDIR)/{o}"))
                .collect();
            let deps: Vec<String> = node
                .dependencies
                .iter()
                .map(|d| format!("$(BUILDDIR)/{d}"))
                .collect();
            let sources: Vec<String> = node
                .sources
                .iter()
                .map(|s| format!("$(SRCROOT)/{s}"))
                .collect();

            for output in outputs {
                let mut rule = format!(
                    "{output}: {}",
                    (sources
                        .iter()
                        .chain(deps.iter())
                        .cloned()
                        .collect::<Vec<_>>())
                    .join(" ")
                );
                if rule.ends_with(':') {
                    rule.push_str(" ");
                }
                content.push_str(&rule);
                content.push('\n');
                content.push_str(&format!(
                    "\t@echo Building {desc}\n",
                    desc = display_name(&node.kind, &node.name)
                ));
                if let Some(cmd) = &node.command {
                    content.push_str(&format!("\t{}\n", cmd));
                } else {
                    content.push_str("\t@touch $@\n");
                }
                content.push('\n');
            }
        }

        let path = out_dir.join("Makefile");
        fs::write(&path, content)?;
        Ok(BackendEmitResult::single(path))
    }
}

fn display_name(kind: &TargetKind, name: &str) -> String {
    match kind {
        TargetKind::Executable => format!("executable {name}"),
        TargetKind::StaticLibrary => format!("static {name}"),
        TargetKind::SharedLibrary => format!("shared {name}"),
        TargetKind::CustomCommand => format!("custom {name}"),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::{ProjectInfo, ProjectManifest, Target};
    use tempfile::tempdir;

    #[test]
    fn writes_makefile() {
        let manifest = ProjectManifest {
            project: ProjectInfo {
                name: "demo".into(),
                version: None,
            },
            targets: vec![Target::StaticLibrary {
                name: "util".into(),
                sources: vec!["src/util.c".into()],
                deps: vec![],
            }],
        };
        let graph = DependencyGraph::from_manifest(&manifest).unwrap();
        let dir = tempdir().unwrap();
        let backend = MakeBackend;
        let result = backend.emit(&graph, dir.path()).unwrap();
        let content = std::fs::read_to_string(&result.files[0]).unwrap();
        assert!(content.contains("util"));
        assert!(content.contains("touch $@"));
    }
}
